const {
    isStatisticEntry,
    getRTTFn,
    getTotalPacketsFn
} = require('../../utils/stats-detection');
const {
    fixedDecMean,
    percentOf,
    round
} = require('../../utils/utils');


/**
 * Return the resolution as a valid number, guard against Object/Null/NaN/Undefined/Infinity values
 *
 * @param {Number} resolution
 * @returns {Number} Valid resolution as a number.
 */
function extractValidResolution(resolution) {

    if (Number.isFinite(resolution)) {
        return resolution;
    }

    return 0;
}

/**
 * Groups resolutions to High Definition, Standard Definition, Low Definition and No Video buckets.
 * Count the total samples as well so we can establish a usage percentage for each of those.
 * @param {ResStatsMap} resStatsMap
 * @param {Number} resolution
 */
function fitResToDefinition(resStatsMap, resolution) {

    ++resStatsMap.totalSamples;

    // Not very elegant but we need it to be fast.
    if (resolution >= 720) {
        // HD
        ++resStatsMap.resTimeShare.hdVideo;
    } else if (resolution >= 360) {
        // SD
        ++resStatsMap.resTimeShare.sdVideo;
    } else if (resolution > 0) {
        // LD
        ++resStatsMap.resTimeShare.ldVideo;
    } else {
        // NV
        ++resStatsMap.resTimeShare.noVideo;
    }
}

/**
 * Compute how much time as a percentage of the total, this session spent send each standard definition.
 *
 * @param {ResStatsMap} resStatsMap
 * @returns {ResTimeSharePct} - Computed time share as a percentage for each video definition
 */
function calculateResTimeSharePct(resStatsMap) {

    const { totalSamples, resTimeShare } = resStatsMap;

    const resTimeSharePct = {};

    // resTimeSharePct values should amount
    resTimeSharePct.hdVideo = percentOf(resTimeShare.hdVideo, totalSamples);
    resTimeSharePct.sdVideo = percentOf(resTimeShare.sdVideo, totalSamples);
    resTimeSharePct.ldVideo = percentOf(resTimeShare.ldVideo, totalSamples);
    resTimeSharePct.noVideo = percentOf(resTimeShare.noVideo, totalSamples);

    return resTimeSharePct;
}

/**
 * Calculate aggregates of the provided resolution map.
 *
 * @param {Object} usedResolutions Contains a map of the used definitions throughout the session.
 * @returns {{min: Number,max: Number, median: Number}}
 */
function calculateResAggregates(usedResolutions) {

    const sortedRes = Object.values(usedResolutions).sort();

    const aggregateValues = {
        min: 0,
        max: 0,
        median: 0
    };

    if (!sortedRes.length) {
        return aggregateValues;
    }

    aggregateValues.min = sortedRes[0];
    aggregateValues.max = sortedRes[sortedRes.length - 1];
    aggregateValues.median = sortedRes[Math.floor(sortedRes.length / 2)];

    return aggregateValues;
}

/**
 * Map resolution to object properties, so we have an aggregated view of what resolutions were used.
 *
 * @param {Object} usedResolutions
 * @param {Number} resolution
 */
function fitResToAggregateMap(usedResolutions, resolution) {
    if (!resolution) {
        return;
    }

    usedResolutions[resolution] = resolution;
}

/**
 *
 * @param {*} outputAggregates
 * @param {*} totalPackets
 */
function aggregateTotalPackets(outputPacketsAggregate, ssrcPackets) {
    if (!ssrcPackets) {
        return;
    }
    const { ssrc } = ssrcPackets;

    const {
        packetsLost: prevPacketsLost = 0,
        packetsSent: prevPacketsSent = 0,
        samples = 0
    } = outputPacketsAggregate[ssrc] || {};
    const {
        packetsLost = 0,
        packetsSent = 0,
        mediaType
    } = ssrcPackets;

    Object.assign(outputPacketsAggregate, {
        [ssrc]: {
            packetsLost: prevPacketsLost <= packetsLost ? packetsLost : prevPacketsLost,
            packetsSent: prevPacketsSent <= packetsSent ? packetsSent : prevPacketsSent,
            samples: samples + 1,
            mediaType
        }
    });
}


/**
 *
 * @param {*} packetsLostMap
 */
function calculatePacketStats(packetsLostMap) {
    const sentMediaTotals = Object.values(packetsLostMap).reduce((acc, currentSsrc) => {

        const { mediaType, packetsLost, packetsSent, samples } = currentSsrc;
        const {
            packetsLost: packetsLostResult = 0,
            packetsSent: packetsSentResult = 0,
            samples: samplesResult = 0
        } = acc[mediaType] || {};

        return { ...acc,
            [mediaType]: {
                packetsLost: packetsLost + packetsLostResult,
                packetsSent: packetsSent + packetsSentResult,
                samples: samples + samplesResult
            }
        };
    }, {});

    return Object.entries(sentMediaTotals).reduce((acc, [ mediaType, packetSummary ]) => {
        const { packetsLost, packetsSent, samples } = packetSummary;

        return { ...acc,
            [mediaType]: {
                ...packetSummary,
                packetsLostMean: round(packetsLost / samples, 2),
                packetsLostPct: percentOf(packetsLost, packetsSent)
            }
        };
    }, {});
}

/**
 * Mean RTT, send and recv bitrate of the active candidate pair
 *
 * @param {*} client
 * @param {*} peerConnectionLog
 */
function stats(client, peerConnectionLog) {
    const feature = {};
    const rtts = [];
    const recv = [];
    const send = [];

    const packetsLostMap = {};

    const usedResolutions = {};

    /**
     * @type {ResStatsMap}
     */
    const resStatsMap = {
        totalSamples: 0,
        resTimeShare: {
            noVideo: 0,
            ldVideo: 0,
            sdVideo: 0,
            hdVideo: 0
        }
    };

    let lastStatsReport;
    let lastTime;

    const getRTT = getRTTFn(client);
    const getTotalPackets = getTotalPacketsFn(client);


    // Iterate over the getStats entries for this specific PC and calculate the average roundTripTime
    // data from the candidate-pair statistic.
    peerConnectionLog.forEach(entry => {
        if (!isStatisticEntry(entry.type)) {
            return;
        }
        const statsReport = entry.value;

        // look for type track, remoteSource: false, audioLevel (0..1)
        Object.keys(statsReport).forEach(id => {
            const report = statsReport[id];
            const rtt = getRTT(statsReport, report);

            rtt && rtts.push(rtt);

            aggregateTotalPackets(packetsLostMap, getTotalPackets(report, statsReport));

            // packetsLost is a cumulative stats thus we just overwrite the value so we don't have to find
            // the last type of stats of a certain type.
            if (report.type === 'ssrc' && id.endsWith('_send') === true) {
                if (report.mediaType === 'video') {
                    const resolution = extractValidResolution(report.frameHeight);

                    fitResToDefinition(resStatsMap, resolution);
                    fitResToAggregateMap(usedResolutions, resolution);
                }
            }
        });
        if (lastStatsReport) {
            Object.keys(statsReport).forEach(id => {
                const report = statsReport[id];
                let bitrate;

                if (report.type === 'candidate-pair' && report.selected === true && lastStatsReport[id]) {
                    bitrate
                        = (8 * (report.bytesReceived - lastStatsReport[id].bytesReceived))
                        / (entry.time - lastTime);

                    // needs to work around resetting counters -
                    // - https://bugs.chromium.org/p/webrtc/issues/detail?id=5361
                    if (bitrate > 0) {
                        recv.push(bitrate);
                    }
                }
                if (report.type === 'candidate-pair' && report.selected === true && lastStatsReport[id]) {
                    bitrate
                        = (8 * (report.bytesSent - lastStatsReport[id].bytesSent))
                        / (entry.time - lastTime);

                    // needs to work around resetting counters
                    // -- https://bugs.chromium.org/p/webrtc/issues/detail?id=5361
                    if (bitrate > 0) {
                        send.push(bitrate);
                    }
                }
            });
        }
        lastStatsReport = statsReport;
        lastTime = entry.time;
    });

    const packetAggregates = calculatePacketStats(packetsLostMap);
    const restTimeSharePct = calculateResTimeSharePct(resStatsMap);
    const resAggregates = calculateResAggregates(usedResolutions);

    feature.NoVideoPct = restTimeSharePct.noVideo;
    feature.LDVideoPct = restTimeSharePct.ldVideo;
    feature.SDVideoPct = restTimeSharePct.sdVideo;
    feature.HDVideoPct = restTimeSharePct.hdVideo;
    feature.minVideoRes = resAggregates.min;
    feature.medianVideoRes = resAggregates.median;
    feature.maxVideoRes = resAggregates.max;

    feature.meanRoundTripTime = round(rtts.reduce((a, b) => a + b, 0) / (rtts.length || 1), 2);
    feature.meanReceivingBitrate = Math.floor(recv.reduce((a, b) => a + b, 0) / (recv.length || 1));
    feature.meanSendingBitrate = Math.floor(send.reduce((a, b) => a + b, 0) / (send.length || 1));

    if (packetAggregates.video) {
        feature.videoPacketsLostTotal = packetAggregates.video.packetsLost;
        feature.videoPacketsSentTotal = packetAggregates.video.packetsSent;
        feature.videoPacketsLostPct = packetAggregates.video.packetsLostPct;
        feature.meanVideoPacketsLost = packetAggregates.video.packetsLostMean;
    }

    if (packetAggregates.audio) {
        feature.audioPacketsLostTotal = packetAggregates.audio.packetsLost;
        feature.audioPacketsSentTotal = packetAggregates.audio.packetsSent;
        feature.audioPacketsLostPct = packetAggregates.audio.packetsLostPct;
        feature.meanAudioPacketsLost = packetAggregates.audio.packetsLostMean;
    }

    return feature;
}


module.exports = { stats };
